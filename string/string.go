package main

import "fmt"

func main() {

	ExampleString()
	fmt.Print("\n")
	ExampleByteSlice()
	fmt.Print("\n")
	ExampleRune()
}

func ExampleString() {
	// Создадим строковый литерал s, значение которого "Это строка".
	// Строка состоит из 10 символов.
	var s string = "Это строка"

	// Однако длина строки len(s) составит 19 байт, т.к. использованные кирилические символы
	// занимают 2 байта, а пробел занимает 1 байт.
	fmt.Printf("Длина строки: %d байт\n", len(s))

	// Посмотрим как взять подстроку
	fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])

	/*
		Попробуем изменить что-то встроке:
		s[3] = 12
		Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.
	*/

	// Изменим строку, создав новую
	s = s + " Новая строка"
	fmt.Printf("%v\n", s)

	// А теперь проитерируемся по этой строке
	for _, b := range s {
		fmt.Printf("%v ", b)
	}
	fmt.Print("\n")

	// Преобразуем строку в слайс байт
	bslice := []byte(s)
	fmt.Printf("%v\n", bslice)

	// Преобразуем слайс байт в строку
	s = string(bslice)
	fmt.Printf("%v\n", s)
}

func ExampleByteSlice() {
	// Используем тип string, который конвертируем в []byte,
	// чтобы не использовать абстрактные цифры
	bs := []byte("Это байтовый срез")

	fmt.Printf("Так байтовый срез выглядит в изнутри: %v\n", bs)

	// Продемонстрируем, что байтовый срез можно изменить,
	// а затем напечатаем его в виде строки
	for i := range bs {
		if bs[i]%2 == 0 {
			bs[i] = bs[i] + 1
			continue
		}
		bs[i] = bs[i] - 1
	}
	fmt.Printf("Измененный байтовый срез: %v\n", bs)
	fmt.Printf("Измененный байтовый срез в виде строки: %s\n", bs)
}

func ExampleRune() {
	// Поступим также, как в работе с типом []byte
	rs := []rune("Это срез рун")

	fmt.Printf("Так выглядит срез рун изнутри: %v\n", rs)

	// Итерируясь мы будем заменять символ 'р' на '*'
	for i := range rs {
		if rs[i] == 'р' {
			rs[i] = '*'
		}
	}
	fmt.Printf("Измененнный срез в виде строки: %s\n", string(rs))

}
